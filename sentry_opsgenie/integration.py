from __future__ import absolute_import

from six.moves.urllib.parse import urlparse

from django import forms
from django.utils.translation import ugettext_lazy as _
from django.core.validators import URLValidator

from sentry import http
from sentry.identity.pipeline import IdentityProviderPipeline
from sentry.integrations import (
    IntegrationInstallation, IntegrationFeatures, IntegrationMetadata, IntegrationProvider, FeatureDescription,
)
from sentry.pipeline import NestedPipelineView
from sentry.pipeline import PipelineView
from sentry.utils.http import absolute_uri

from zenalerts import ZenAlerts
from zenalerts import Configuration as OpsgenieConfiguration

DESCRIPTION = """
Connect your Sentry organization to your Opsgenie app, and start
getting alerts for errors right in front of you where all the
action happens in your office!
"""

FEATURES = [
    FeatureDescription(
        """
        Unfurls Sentry URLs directly within opsgenie, providing you context and
        actionability on issues right at your fingertips.
        """,
        IntegrationFeatures.CHAT_UNFURL,
    ),
    FeatureDescription(
        """
        Resolve, ignore, and assign issues with minimal context switching.
        """,
        IntegrationFeatures.ACTION_NOTIFICATION,
    ),
    FeatureDescription(
        """
        Configure rule based Opsgenie alerts to automatically be posted to a
        specific team/user. Want any error that's happening more than 100 times a
        minute to be posted with P1 priority? Setup a rule for it!
        """,
        IntegrationFeatures.ALERT_RULE,
    ),
]

setup_alert = {
    'type': 'info',
    'text': 'The Opsgenie integration adds a new Alert Rule action to all projects. To enable automatic alerts sent to Opsgenie you must create a rule using the opsgenie workspace action in your project settings.',
}

metadata = IntegrationMetadata(
    description=_(DESCRIPTION.strip()),
    features=FEATURES,
    author='Kumarappan Arumugam',
    noun=_('Installation'),
    issue_url='https://github.com/kumarappan-arumugam/sentry-opsgenie/issues/new?title=Opsgenie%20Integration:%20&labels=Component%3A%20Integrations',
    source_url='https://github.com/kumarappan-arumugam/sentry-opsgenie/tree/master/src/sentry-opsgenie',
    aspects={
        'alerts': [setup_alert],
    }
)


class InstallationForm(forms.Form):
    api_url = forms.CharField(
        label="Opsgenie Api Url",
        # choices=[],
        help_text=_('The "Api Url" for your Opsgenie api integration, differs based on region'),
        widget=forms.TextInput(
            attrs={'placeholder': _('https://api.opsgenie.com')}
        ),
    )
    api_key = forms.CharField(
        label="Opsgenie Api Key",
        help_text=_('We require a "global" api integration key to be '
                    'configured. If it\'s not a global key then alerts can be sent only '
                    'to specific team. This can be generated by following '
                    'the instructions at https://docs.opsgenie.com/docs/api-key-management'
                    ),
        widget=forms.TextInput(
            attrs={'placeholder': _('XXXXXXXXXXXXXXXXXXXXXXXXXXX')}
        )
    )
    account_name = forms.HiddenInput()

    def __init__(self, *args, **kwargs):
        super(InstallationForm, self).__init__(*args, **kwargs)

    def is_valid(self):
        if not super().is_valid():
            return False

        url_validator = URLValidator()
        try:
            url_validator(self.cleaned_data.get('api_url'))
        except Exception as e:
            raise forms.ValidationError(_("API Url is not in valid format - %(error)s"),
                                        code='test-error',
                                        params={'error': e.message}
                                    )

        config = OpsgenieConfiguration(
                    apikey=self.cleaned_data.get('api_key'),
                    endpoint=self.cleaned_data.get('api_url')
                )
        client = ZenAlerts(config)
        try:
            account = client.accounts.get_account()
        except Exception as e:
            raise forms.ValidationError(_("API key is not functional, test failed with error %(error)s"),
                                        code='test-error',
                                        params={'error': e.message}
                                    )
        else:
            self.cleaned_data['name'] = account.name

        return True


class InstallationConfigView(PipelineView):
    def dispatch(self, request, pipeline):
        if request.method == 'POST':
            form = InstallationForm(request.POST)
            if form.is_valid():
                form_data = form.cleaned_data
                pipeline.bind_state('opsgenie', form_data)

                # pipeline.bind_state('oauth_config_information', {
                #     "access_token_url": u"https://{}/login/oauth/access_token".format(form_data.get('url')),
                #     "authorize_url": u"https://{}/login/oauth/authorize".format(form_data.get('url')),
                #     "client_id": form_data.get('client_id'),
                #     "client_secret": form_data.get('client_secret'),
                #     "verify_ssl": form_data.get('verify_ssl'),
                # })

                return pipeline.next_step()
        else:
            form = InstallationForm()

        return render_to_response(
            template='opsgenie-config.html',
            context={
                'form': form,
            },
            request=request,
        )

class OpsgenieIntegration(IntegrationInstallation):
    """
    An IntegrationInstallation represents an installed integration and manages the
    core functionality of the integration.
    """
    def get_client(self):
        # Return the api client for a given provider
        config = OpsgenieConfiguration(
                    apikey=self.model.metadata['account']['api_key'],
                    endpoint=self.model.metadata['account']['api_url']
                )
        return ZenAlerts(config)
        # return OpsgenieClient(
        #     api_url=self.model.metadata['account']['api_url'],
        #     api_key=self.model.metadata['account']['api_key'],
        # )

    # def error_message_from_json(self, data):
    #     return data.get('message', 'unknown error')

class OpsgenieIntegrationProvider(IntegrationProvider):
    """
    An integration provider describes a third party that can be registered within Sentry.
    The core behavior is simply how to add the integration (the setup
    pipeline), which will likely use a nested pipeline for identity
    authentication, and what kind of configuration is stored.
    This is similar to Sentry's legacy 'plugin' information, except that an
    integration is lives as an instance in the database, and the ``IntegrationProvider``
    class is just a descriptor for how that object functions, and what behavior
    it provides (such as extensions provided).
    """

    key = 'opsgenie'
    name = 'Opsgenie'
    metadata = metadata
    features = frozenset([
        IntegrationFeatures.ACTION_NOTIFICATION,
        IntegrationFeatures.CHAT_UNFURL,
        IntegrationFeatures.ALERT_RULE,
    ])

    integration_cls = OpsgenieIntegration

    setup_dialog_config = {
        'width': 600,
        'height': 900,
    }

    # def _make_identity_pipeline_view(self):
    #     """
    #     Make the nested identity provider view. It is important that this view is
    #     not constructed until we reach this step and the
    #     ``oauth_config_information`` is available in the pipeline state. This
    #     method should be late bound into the pipeline vies.
    #     """
    #     identity_pipeline_config = dict(
    #         oauth_scopes=(),
    #         redirect_url=absolute_uri('/extensions/github-enterprise/setup/'),
    #         **self.pipeline.fetch_state('oauth_config_information')
    #     )

    #     return NestedPipelineView(
    #         bind_key='identity',
    #         provider_key='github_enterprise',
    #         pipeline_cls=IdentityProviderPipeline,
    #         config=identity_pipeline_config,
    #     )

    def get_pipeline_views(self):
        views = super(OpsgenieIntegrationProvider, self).get_pipeline_views()
        views.append(InstallationConfigView())
        views.append(OpsgenieFinishedView())
        return views

    # def get_pipeline_views(self):
    #     identity_pipeline_config = dict(
    #         oauth_scopes=(),
    #         redirect_url=absolute_uri('/extensions/opsgenie/setup/'),
    #         **self.pipeline.fetch_state('oauth_config_information')
    #     )

    #     identity_pipeline_view = NestedPipelineView(
    #         bind_key='identity',
    #         provider_key='opsgenie',
    #         pipeline_cls=IdentityProviderPipeline,
    #         config=identity_pipeline_config,
    #     )

    #     return [identity_pipeline_view]

    def post_install(self, integration, organization):
        # create a test opsgenie alert?
        pass

    def get_installation_info(self, api_key, api_url):
        payload = {
            'token': access_token,
        }

        session = http.build_session()
        resp = session.get('https://slack.com/api/team.info', params=payload)
        resp.raise_for_status()
        resp = resp.json()

        return resp['team']

    def get_user_info(self, api_key, api_url):
        payload = {
            'token': user_token,
        }

        session = http.build_session()
        resp = session.get('https://slack.com/api/auth.test', params=payload)
        resp.raise_for_status()
        resp = resp.json()

        return resp['user_id']

    # def build_integration(self, state):
    #     identity = state['identity']['data']
    #     assert identity['ok']

    #     user = get_user_info(installation_data['api_key'], installation_data['api_url'])
    #     installation = self.get_installation_info(
    #         installation_data['api_key'],
    #         installation_data['api_url']
    #     )

    #     return {
    #         'name': installation['name'],
    #         'external_id': u'{}:{}'.format(installation['team_name'], installation['team_id']),
    #         'metadata': {
    #             'api_key': installation_data['api_key'],
    #             'api_url': installation_data['api_url'],
    #         },
    #         'user_identity': {
    #             'type': 'opsgenie',
    #             'external_id': user['id'],
    #             'scopes': [], # Opsgenie do not have user scopes
    #             'data': {},
    #         },
    #     }

    def build_integration(self, state):
        state['account'] = {
            'api_key': state['opsgenie']['api_key'],
            'api_url': state['opsgenie']['api_url'],
            'account_name': state['opsgenie']['account_name'],
        }

        return super(
            OpsgenieIntegrationProvider,
            self
        ).build_integration(state)

class OpsgenieFinishedView(PipelineView):
    def dispatch(self, request, pipeline):
        pipeline.finish_pipeline()

        messages.add_message(request, messages.SUCCESS, 'Opsgenie integration installed.')

        return HttpResponseRedirect(
            absolute_uri(u'/settings/{}/integrations/opsgenie/{}/'.format(
                pipeline.organization.slug,
                pipeline.integration.id,
            ))
        )
